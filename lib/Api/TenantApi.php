<?php
/**
 * TenantApi
 * PHP version 7.1+
 *
 * @category Class
 * @package  Killbill\Client\Swagger
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Kill Bill
 *
 * Kill Bill is an open-source billing and payments platform
 *
 * OpenAPI spec version: 0.22.11
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.22
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Killbill\Client\Swagger\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\Psr7\Response;
use GuzzleHttp\RequestOptions;
use Killbill\Client\Swagger\ApiException;
use Killbill\Client\Swagger\Configuration;
use Killbill\Client\Swagger\HeaderSelector;
use Killbill\Client\Swagger\ObjectSerializer;

/**
 * TenantApi Class Doc Comment
 *
 * @category Class
 * @package  Killbill\Client\Swagger
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class TenantApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createTenant
     *
     * Create a tenant
     *
     * @param \Killbill\Client\Swagger\Model\Tenant $body body (required)
     * @param string $xKillbillCreatedBy xKillbillCreatedBy (required)
     * @param string|null $xKillbillReason xKillbillReason (optional)
     * @param string|null $xKillbillComment xKillbillComment (optional)
     * @param bool|null $useGlobalDefault useGlobalDefault (optional, default to false)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Killbill\Client\Swagger\Model\Tenant
     */
    public function createTenant($body, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null, $useGlobalDefault = 'false')
    {
        list($response) = $this->createTenantWithHttpInfo($body, $xKillbillCreatedBy, $xKillbillReason, $xKillbillComment, $useGlobalDefault);
        return $response;
    }

    /**
     * Operation createTenantWithHttpInfo
     *
     * Create a tenant
     *
     * @param \Killbill\Client\Swagger\Model\Tenant $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param bool $useGlobalDefault (optional, default to false)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Killbill\Client\Swagger\Model\Tenant, HTTP status code, HTTP response headers (array of strings)
     */
    public function createTenantWithHttpInfo($body, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null, $useGlobalDefault = 'false')
    {
        $returnType = '\Killbill\Client\Swagger\Model\Tenant';
        $request = $this->createTenantRequest($body, $xKillbillCreatedBy, $xKillbillReason, $xKillbillComment, $useGlobalDefault);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Killbill\Client\Swagger\Model\Tenant',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createTenantAsync
     *
     * Create a tenant
     *
     * @param \Killbill\Client\Swagger\Model\Tenant $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param bool $useGlobalDefault (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTenantAsync($body, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null, $useGlobalDefault = 'false')
    {
        return $this->createTenantAsyncWithHttpInfo($body, $xKillbillCreatedBy, $xKillbillReason, $xKillbillComment, $useGlobalDefault)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createTenantAsyncWithHttpInfo
     *
     * Create a tenant
     *
     * @param \Killbill\Client\Swagger\Model\Tenant $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param bool $useGlobalDefault (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTenantAsyncWithHttpInfo($body, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null, $useGlobalDefault = 'false')
    {
        $returnType = '\Killbill\Client\Swagger\Model\Tenant';
        $request = $this->createTenantRequest($body, $xKillbillCreatedBy, $xKillbillReason, $xKillbillComment, $useGlobalDefault);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createTenant'
     *
     * @param \Killbill\Client\Swagger\Model\Tenant $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param bool $useGlobalDefault (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createTenantRequest($body, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null, $useGlobalDefault = 'false')
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createTenant'
            );
        }
        // verify the required parameter 'xKillbillCreatedBy' is set
        if ($xKillbillCreatedBy === null || (is_array($xKillbillCreatedBy) && count($xKillbillCreatedBy) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $xKillbillCreatedBy when calling createTenant'
            );
        }

        $resourcePath = '/1.0/kb/tenants';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($useGlobalDefault !== null) {
            $queryParams['useGlobalDefault'] = ObjectSerializer::toQueryValue($useGlobalDefault);
        }
        // header params
        if ($xKillbillCreatedBy !== null) {
            $headerParams['X-Killbill-CreatedBy'] = ObjectSerializer::toHeaderValue($xKillbillCreatedBy);
        }
        // header params
        if ($xKillbillReason !== null) {
            $headerParams['X-Killbill-Reason'] = ObjectSerializer::toHeaderValue($xKillbillReason);
        }
        // header params
        if ($xKillbillComment !== null) {
            $headerParams['X-Killbill-Comment'] = ObjectSerializer::toHeaderValue($xKillbillComment);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePerTenantConfiguration
     *
     * Delete a per tenant configuration (system properties)
     *
     * @param string $xKillbillCreatedBy xKillbillCreatedBy (required)
     * @param string|null $xKillbillReason xKillbillReason (optional)
     * @param string|null $xKillbillComment xKillbillComment (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deletePerTenantConfiguration($xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        $this->deletePerTenantConfigurationWithHttpInfo($xKillbillCreatedBy, $xKillbillReason, $xKillbillComment);
    }

    /**
     * Operation deletePerTenantConfigurationWithHttpInfo
     *
     * Delete a per tenant configuration (system properties)
     *
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePerTenantConfigurationWithHttpInfo($xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        $returnType = null;
        $request = $this->deletePerTenantConfigurationRequest($xKillbillCreatedBy, $xKillbillReason, $xKillbillComment);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deletePerTenantConfigurationAsync
     *
     * Delete a per tenant configuration (system properties)
     *
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePerTenantConfigurationAsync($xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        return $this->deletePerTenantConfigurationAsyncWithHttpInfo($xKillbillCreatedBy, $xKillbillReason, $xKillbillComment)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePerTenantConfigurationAsyncWithHttpInfo
     *
     * Delete a per tenant configuration (system properties)
     *
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePerTenantConfigurationAsyncWithHttpInfo($xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        $returnType = null;
        $request = $this->deletePerTenantConfigurationRequest($xKillbillCreatedBy, $xKillbillReason, $xKillbillComment);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePerTenantConfiguration'
     *
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePerTenantConfigurationRequest($xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        // verify the required parameter 'xKillbillCreatedBy' is set
        if ($xKillbillCreatedBy === null || (is_array($xKillbillCreatedBy) && count($xKillbillCreatedBy) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $xKillbillCreatedBy when calling deletePerTenantConfiguration'
            );
        }

        $resourcePath = '/1.0/kb/tenants/uploadPerTenantConfig';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($xKillbillCreatedBy !== null) {
            $headerParams['X-Killbill-CreatedBy'] = ObjectSerializer::toHeaderValue($xKillbillCreatedBy);
        }
        // header params
        if ($xKillbillReason !== null) {
            $headerParams['X-Killbill-Reason'] = ObjectSerializer::toHeaderValue($xKillbillReason);
        }
        // header params
        if ($xKillbillComment !== null) {
            $headerParams['X-Killbill-Comment'] = ObjectSerializer::toHeaderValue($xKillbillComment);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePluginConfiguration
     *
     * Delete a per tenant configuration for a plugin
     *
     * @param string $pluginName pluginName (required)
     * @param string $xKillbillCreatedBy xKillbillCreatedBy (required)
     * @param string|null $xKillbillReason xKillbillReason (optional)
     * @param string|null $xKillbillComment xKillbillComment (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deletePluginConfiguration($pluginName, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        $this->deletePluginConfigurationWithHttpInfo($pluginName, $xKillbillCreatedBy, $xKillbillReason, $xKillbillComment);
    }

    /**
     * Operation deletePluginConfigurationWithHttpInfo
     *
     * Delete a per tenant configuration for a plugin
     *
     * @param string $pluginName (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePluginConfigurationWithHttpInfo($pluginName, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        $returnType = null;
        $request = $this->deletePluginConfigurationRequest($pluginName, $xKillbillCreatedBy, $xKillbillReason, $xKillbillComment);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deletePluginConfigurationAsync
     *
     * Delete a per tenant configuration for a plugin
     *
     * @param string $pluginName (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePluginConfigurationAsync($pluginName, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        return $this->deletePluginConfigurationAsyncWithHttpInfo($pluginName, $xKillbillCreatedBy, $xKillbillReason, $xKillbillComment)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePluginConfigurationAsyncWithHttpInfo
     *
     * Delete a per tenant configuration for a plugin
     *
     * @param string $pluginName (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePluginConfigurationAsyncWithHttpInfo($pluginName, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        $returnType = null;
        $request = $this->deletePluginConfigurationRequest($pluginName, $xKillbillCreatedBy, $xKillbillReason, $xKillbillComment);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePluginConfiguration'
     *
     * @param string $pluginName (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePluginConfigurationRequest($pluginName, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        // verify the required parameter 'pluginName' is set
        if ($pluginName === null || (is_array($pluginName) && count($pluginName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pluginName when calling deletePluginConfiguration'
            );
        }
        // verify the required parameter 'xKillbillCreatedBy' is set
        if ($xKillbillCreatedBy === null || (is_array($xKillbillCreatedBy) && count($xKillbillCreatedBy) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $xKillbillCreatedBy when calling deletePluginConfiguration'
            );
        }

        $resourcePath = '/1.0/kb/tenants/uploadPluginConfig/{pluginName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($xKillbillCreatedBy !== null) {
            $headerParams['X-Killbill-CreatedBy'] = ObjectSerializer::toHeaderValue($xKillbillCreatedBy);
        }
        // header params
        if ($xKillbillReason !== null) {
            $headerParams['X-Killbill-Reason'] = ObjectSerializer::toHeaderValue($xKillbillReason);
        }
        // header params
        if ($xKillbillComment !== null) {
            $headerParams['X-Killbill-Comment'] = ObjectSerializer::toHeaderValue($xKillbillComment);
        }

        // path params
        if ($pluginName !== null) {
            $resourcePath = str_replace(
                '{' . 'pluginName' . '}',
                ObjectSerializer::toPathValue($pluginName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePluginPaymentStateMachineConfig
     *
     * Delete a per tenant payment state machine for a plugin
     *
     * @param string $pluginName pluginName (required)
     * @param string $xKillbillCreatedBy xKillbillCreatedBy (required)
     * @param string|null $xKillbillReason xKillbillReason (optional)
     * @param string|null $xKillbillComment xKillbillComment (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deletePluginPaymentStateMachineConfig($pluginName, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        $this->deletePluginPaymentStateMachineConfigWithHttpInfo($pluginName, $xKillbillCreatedBy, $xKillbillReason, $xKillbillComment);
    }

    /**
     * Operation deletePluginPaymentStateMachineConfigWithHttpInfo
     *
     * Delete a per tenant payment state machine for a plugin
     *
     * @param string $pluginName (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePluginPaymentStateMachineConfigWithHttpInfo($pluginName, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        $returnType = null;
        $request = $this->deletePluginPaymentStateMachineConfigRequest($pluginName, $xKillbillCreatedBy, $xKillbillReason, $xKillbillComment);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deletePluginPaymentStateMachineConfigAsync
     *
     * Delete a per tenant payment state machine for a plugin
     *
     * @param string $pluginName (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePluginPaymentStateMachineConfigAsync($pluginName, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        return $this->deletePluginPaymentStateMachineConfigAsyncWithHttpInfo($pluginName, $xKillbillCreatedBy, $xKillbillReason, $xKillbillComment)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePluginPaymentStateMachineConfigAsyncWithHttpInfo
     *
     * Delete a per tenant payment state machine for a plugin
     *
     * @param string $pluginName (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePluginPaymentStateMachineConfigAsyncWithHttpInfo($pluginName, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        $returnType = null;
        $request = $this->deletePluginPaymentStateMachineConfigRequest($pluginName, $xKillbillCreatedBy, $xKillbillReason, $xKillbillComment);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePluginPaymentStateMachineConfig'
     *
     * @param string $pluginName (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePluginPaymentStateMachineConfigRequest($pluginName, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        // verify the required parameter 'pluginName' is set
        if ($pluginName === null || (is_array($pluginName) && count($pluginName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pluginName when calling deletePluginPaymentStateMachineConfig'
            );
        }
        // verify the required parameter 'xKillbillCreatedBy' is set
        if ($xKillbillCreatedBy === null || (is_array($xKillbillCreatedBy) && count($xKillbillCreatedBy) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $xKillbillCreatedBy when calling deletePluginPaymentStateMachineConfig'
            );
        }

        $resourcePath = '/1.0/kb/tenants/uploadPluginPaymentStateMachineConfig/{pluginName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($xKillbillCreatedBy !== null) {
            $headerParams['X-Killbill-CreatedBy'] = ObjectSerializer::toHeaderValue($xKillbillCreatedBy);
        }
        // header params
        if ($xKillbillReason !== null) {
            $headerParams['X-Killbill-Reason'] = ObjectSerializer::toHeaderValue($xKillbillReason);
        }
        // header params
        if ($xKillbillComment !== null) {
            $headerParams['X-Killbill-Comment'] = ObjectSerializer::toHeaderValue($xKillbillComment);
        }

        // path params
        if ($pluginName !== null) {
            $resourcePath = str_replace(
                '{' . 'pluginName' . '}',
                ObjectSerializer::toPathValue($pluginName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePushNotificationCallbacks
     *
     * Delete a push notification
     *
     * @param string $xKillbillCreatedBy xKillbillCreatedBy (required)
     * @param string|null $xKillbillReason xKillbillReason (optional)
     * @param string|null $xKillbillComment xKillbillComment (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deletePushNotificationCallbacks($xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        $this->deletePushNotificationCallbacksWithHttpInfo($xKillbillCreatedBy, $xKillbillReason, $xKillbillComment);
    }

    /**
     * Operation deletePushNotificationCallbacksWithHttpInfo
     *
     * Delete a push notification
     *
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePushNotificationCallbacksWithHttpInfo($xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        $returnType = null;
        $request = $this->deletePushNotificationCallbacksRequest($xKillbillCreatedBy, $xKillbillReason, $xKillbillComment);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deletePushNotificationCallbacksAsync
     *
     * Delete a push notification
     *
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePushNotificationCallbacksAsync($xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        return $this->deletePushNotificationCallbacksAsyncWithHttpInfo($xKillbillCreatedBy, $xKillbillReason, $xKillbillComment)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePushNotificationCallbacksAsyncWithHttpInfo
     *
     * Delete a push notification
     *
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePushNotificationCallbacksAsyncWithHttpInfo($xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        $returnType = null;
        $request = $this->deletePushNotificationCallbacksRequest($xKillbillCreatedBy, $xKillbillReason, $xKillbillComment);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePushNotificationCallbacks'
     *
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePushNotificationCallbacksRequest($xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        // verify the required parameter 'xKillbillCreatedBy' is set
        if ($xKillbillCreatedBy === null || (is_array($xKillbillCreatedBy) && count($xKillbillCreatedBy) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $xKillbillCreatedBy when calling deletePushNotificationCallbacks'
            );
        }

        $resourcePath = '/1.0/kb/tenants/registerNotificationCallback';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($xKillbillCreatedBy !== null) {
            $headerParams['X-Killbill-CreatedBy'] = ObjectSerializer::toHeaderValue($xKillbillCreatedBy);
        }
        // header params
        if ($xKillbillReason !== null) {
            $headerParams['X-Killbill-Reason'] = ObjectSerializer::toHeaderValue($xKillbillReason);
        }
        // header params
        if ($xKillbillComment !== null) {
            $headerParams['X-Killbill-Comment'] = ObjectSerializer::toHeaderValue($xKillbillComment);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteUserKeyValue
     *
     * Delete  a per tenant user key/value
     *
     * @param string $keyName keyName (required)
     * @param string $xKillbillCreatedBy xKillbillCreatedBy (required)
     * @param string|null $xKillbillReason xKillbillReason (optional)
     * @param string|null $xKillbillComment xKillbillComment (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteUserKeyValue($keyName, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        $this->deleteUserKeyValueWithHttpInfo($keyName, $xKillbillCreatedBy, $xKillbillReason, $xKillbillComment);
    }

    /**
     * Operation deleteUserKeyValueWithHttpInfo
     *
     * Delete  a per tenant user key/value
     *
     * @param string $keyName (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteUserKeyValueWithHttpInfo($keyName, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        $returnType = null;
        $request = $this->deleteUserKeyValueRequest($keyName, $xKillbillCreatedBy, $xKillbillReason, $xKillbillComment);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteUserKeyValueAsync
     *
     * Delete  a per tenant user key/value
     *
     * @param string $keyName (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteUserKeyValueAsync($keyName, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        return $this->deleteUserKeyValueAsyncWithHttpInfo($keyName, $xKillbillCreatedBy, $xKillbillReason, $xKillbillComment)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteUserKeyValueAsyncWithHttpInfo
     *
     * Delete  a per tenant user key/value
     *
     * @param string $keyName (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteUserKeyValueAsyncWithHttpInfo($keyName, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        $returnType = null;
        $request = $this->deleteUserKeyValueRequest($keyName, $xKillbillCreatedBy, $xKillbillReason, $xKillbillComment);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteUserKeyValue'
     *
     * @param string $keyName (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteUserKeyValueRequest($keyName, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        // verify the required parameter 'keyName' is set
        if ($keyName === null || (is_array($keyName) && count($keyName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $keyName when calling deleteUserKeyValue'
            );
        }
        // verify the required parameter 'xKillbillCreatedBy' is set
        if ($xKillbillCreatedBy === null || (is_array($xKillbillCreatedBy) && count($xKillbillCreatedBy) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $xKillbillCreatedBy when calling deleteUserKeyValue'
            );
        }

        $resourcePath = '/1.0/kb/tenants/userKeyValue/{keyName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($xKillbillCreatedBy !== null) {
            $headerParams['X-Killbill-CreatedBy'] = ObjectSerializer::toHeaderValue($xKillbillCreatedBy);
        }
        // header params
        if ($xKillbillReason !== null) {
            $headerParams['X-Killbill-Reason'] = ObjectSerializer::toHeaderValue($xKillbillReason);
        }
        // header params
        if ($xKillbillComment !== null) {
            $headerParams['X-Killbill-Comment'] = ObjectSerializer::toHeaderValue($xKillbillComment);
        }

        // path params
        if ($keyName !== null) {
            $resourcePath = str_replace(
                '{' . 'keyName' . '}',
                ObjectSerializer::toPathValue($keyName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllPluginConfiguration
     *
     * Retrieve a per tenant key value based on key prefix
     *
     * @param string $keyPrefix keyPrefix (required)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Killbill\Client\Swagger\Model\TenantKeyValue
     */
    public function getAllPluginConfiguration($keyPrefix)
    {
        list($response) = $this->getAllPluginConfigurationWithHttpInfo($keyPrefix);
        return $response;
    }

    /**
     * Operation getAllPluginConfigurationWithHttpInfo
     *
     * Retrieve a per tenant key value based on key prefix
     *
     * @param string $keyPrefix (required)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Killbill\Client\Swagger\Model\TenantKeyValue, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllPluginConfigurationWithHttpInfo($keyPrefix)
    {
        $returnType = '\Killbill\Client\Swagger\Model\TenantKeyValue';
        $request = $this->getAllPluginConfigurationRequest($keyPrefix);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Killbill\Client\Swagger\Model\TenantKeyValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAllPluginConfigurationAsync
     *
     * Retrieve a per tenant key value based on key prefix
     *
     * @param string $keyPrefix (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllPluginConfigurationAsync($keyPrefix)
    {
        return $this->getAllPluginConfigurationAsyncWithHttpInfo($keyPrefix)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllPluginConfigurationAsyncWithHttpInfo
     *
     * Retrieve a per tenant key value based on key prefix
     *
     * @param string $keyPrefix (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllPluginConfigurationAsyncWithHttpInfo($keyPrefix)
    {
        $returnType = '\Killbill\Client\Swagger\Model\TenantKeyValue';
        $request = $this->getAllPluginConfigurationRequest($keyPrefix);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllPluginConfiguration'
     *
     * @param string $keyPrefix (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAllPluginConfigurationRequest($keyPrefix)
    {
        // verify the required parameter 'keyPrefix' is set
        if ($keyPrefix === null || (is_array($keyPrefix) && count($keyPrefix) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $keyPrefix when calling getAllPluginConfiguration'
            );
        }

        $resourcePath = '/1.0/kb/tenants/uploadPerTenantConfig/{keyPrefix}/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($keyPrefix !== null) {
            $resourcePath = str_replace(
                '{' . 'keyPrefix' . '}',
                ObjectSerializer::toPathValue($keyPrefix),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPerTenantConfiguration
     *
     * Retrieve a per tenant configuration (system properties)
     *
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Killbill\Client\Swagger\Model\TenantKeyValue
     */
    public function getPerTenantConfiguration()
    {
        list($response) = $this->getPerTenantConfigurationWithHttpInfo();
        return $response;
    }

    /**
     * Operation getPerTenantConfigurationWithHttpInfo
     *
     * Retrieve a per tenant configuration (system properties)
     *
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Killbill\Client\Swagger\Model\TenantKeyValue, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPerTenantConfigurationWithHttpInfo()
    {
        $returnType = '\Killbill\Client\Swagger\Model\TenantKeyValue';
        $request = $this->getPerTenantConfigurationRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Killbill\Client\Swagger\Model\TenantKeyValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPerTenantConfigurationAsync
     *
     * Retrieve a per tenant configuration (system properties)
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPerTenantConfigurationAsync()
    {
        return $this->getPerTenantConfigurationAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPerTenantConfigurationAsyncWithHttpInfo
     *
     * Retrieve a per tenant configuration (system properties)
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPerTenantConfigurationAsyncWithHttpInfo()
    {
        $returnType = '\Killbill\Client\Swagger\Model\TenantKeyValue';
        $request = $this->getPerTenantConfigurationRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPerTenantConfiguration'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPerTenantConfigurationRequest()
    {

        $resourcePath = '/1.0/kb/tenants/uploadPerTenantConfig';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPluginConfiguration
     *
     * Retrieve a per tenant configuration for a plugin
     *
     * @param string $pluginName pluginName (required)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Killbill\Client\Swagger\Model\TenantKeyValue
     */
    public function getPluginConfiguration($pluginName)
    {
        list($response) = $this->getPluginConfigurationWithHttpInfo($pluginName);
        return $response;
    }

    /**
     * Operation getPluginConfigurationWithHttpInfo
     *
     * Retrieve a per tenant configuration for a plugin
     *
     * @param string $pluginName (required)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Killbill\Client\Swagger\Model\TenantKeyValue, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPluginConfigurationWithHttpInfo($pluginName)
    {
        $returnType = '\Killbill\Client\Swagger\Model\TenantKeyValue';
        $request = $this->getPluginConfigurationRequest($pluginName);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Killbill\Client\Swagger\Model\TenantKeyValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPluginConfigurationAsync
     *
     * Retrieve a per tenant configuration for a plugin
     *
     * @param string $pluginName (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPluginConfigurationAsync($pluginName)
    {
        return $this->getPluginConfigurationAsyncWithHttpInfo($pluginName)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPluginConfigurationAsyncWithHttpInfo
     *
     * Retrieve a per tenant configuration for a plugin
     *
     * @param string $pluginName (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPluginConfigurationAsyncWithHttpInfo($pluginName)
    {
        $returnType = '\Killbill\Client\Swagger\Model\TenantKeyValue';
        $request = $this->getPluginConfigurationRequest($pluginName);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPluginConfiguration'
     *
     * @param string $pluginName (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPluginConfigurationRequest($pluginName)
    {
        // verify the required parameter 'pluginName' is set
        if ($pluginName === null || (is_array($pluginName) && count($pluginName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pluginName when calling getPluginConfiguration'
            );
        }

        $resourcePath = '/1.0/kb/tenants/uploadPluginConfig/{pluginName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($pluginName !== null) {
            $resourcePath = str_replace(
                '{' . 'pluginName' . '}',
                ObjectSerializer::toPathValue($pluginName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPluginPaymentStateMachineConfig
     *
     * Retrieve a per tenant payment state machine for a plugin
     *
     * @param string $pluginName pluginName (required)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Killbill\Client\Swagger\Model\TenantKeyValue
     */
    public function getPluginPaymentStateMachineConfig($pluginName)
    {
        list($response) = $this->getPluginPaymentStateMachineConfigWithHttpInfo($pluginName);
        return $response;
    }

    /**
     * Operation getPluginPaymentStateMachineConfigWithHttpInfo
     *
     * Retrieve a per tenant payment state machine for a plugin
     *
     * @param string $pluginName (required)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Killbill\Client\Swagger\Model\TenantKeyValue, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPluginPaymentStateMachineConfigWithHttpInfo($pluginName)
    {
        $returnType = '\Killbill\Client\Swagger\Model\TenantKeyValue';
        $request = $this->getPluginPaymentStateMachineConfigRequest($pluginName);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Killbill\Client\Swagger\Model\TenantKeyValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPluginPaymentStateMachineConfigAsync
     *
     * Retrieve a per tenant payment state machine for a plugin
     *
     * @param string $pluginName (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPluginPaymentStateMachineConfigAsync($pluginName)
    {
        return $this->getPluginPaymentStateMachineConfigAsyncWithHttpInfo($pluginName)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPluginPaymentStateMachineConfigAsyncWithHttpInfo
     *
     * Retrieve a per tenant payment state machine for a plugin
     *
     * @param string $pluginName (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPluginPaymentStateMachineConfigAsyncWithHttpInfo($pluginName)
    {
        $returnType = '\Killbill\Client\Swagger\Model\TenantKeyValue';
        $request = $this->getPluginPaymentStateMachineConfigRequest($pluginName);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPluginPaymentStateMachineConfig'
     *
     * @param string $pluginName (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPluginPaymentStateMachineConfigRequest($pluginName)
    {
        // verify the required parameter 'pluginName' is set
        if ($pluginName === null || (is_array($pluginName) && count($pluginName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pluginName when calling getPluginPaymentStateMachineConfig'
            );
        }

        $resourcePath = '/1.0/kb/tenants/uploadPluginPaymentStateMachineConfig/{pluginName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($pluginName !== null) {
            $resourcePath = str_replace(
                '{' . 'pluginName' . '}',
                ObjectSerializer::toPathValue($pluginName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPushNotificationCallbacks
     *
     * Retrieve a push notification
     *
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Killbill\Client\Swagger\Model\TenantKeyValue
     */
    public function getPushNotificationCallbacks()
    {
        list($response) = $this->getPushNotificationCallbacksWithHttpInfo();
        return $response;
    }

    /**
     * Operation getPushNotificationCallbacksWithHttpInfo
     *
     * Retrieve a push notification
     *
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Killbill\Client\Swagger\Model\TenantKeyValue, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPushNotificationCallbacksWithHttpInfo()
    {
        $returnType = '\Killbill\Client\Swagger\Model\TenantKeyValue';
        $request = $this->getPushNotificationCallbacksRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Killbill\Client\Swagger\Model\TenantKeyValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPushNotificationCallbacksAsync
     *
     * Retrieve a push notification
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPushNotificationCallbacksAsync()
    {
        return $this->getPushNotificationCallbacksAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPushNotificationCallbacksAsyncWithHttpInfo
     *
     * Retrieve a push notification
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPushNotificationCallbacksAsyncWithHttpInfo()
    {
        $returnType = '\Killbill\Client\Swagger\Model\TenantKeyValue';
        $request = $this->getPushNotificationCallbacksRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPushNotificationCallbacks'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPushNotificationCallbacksRequest()
    {

        $resourcePath = '/1.0/kb/tenants/registerNotificationCallback';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTenant
     *
     * Retrieve a tenant by id
     *
     * @param string $tenantId tenantId (required)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Killbill\Client\Swagger\Model\Tenant
     */
    public function getTenant($tenantId)
    {
        list($response) = $this->getTenantWithHttpInfo($tenantId);
        return $response;
    }

    /**
     * Operation getTenantWithHttpInfo
     *
     * Retrieve a tenant by id
     *
     * @param string $tenantId (required)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Killbill\Client\Swagger\Model\Tenant, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTenantWithHttpInfo($tenantId)
    {
        $returnType = '\Killbill\Client\Swagger\Model\Tenant';
        $request = $this->getTenantRequest($tenantId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Killbill\Client\Swagger\Model\Tenant',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTenantAsync
     *
     * Retrieve a tenant by id
     *
     * @param string $tenantId (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTenantAsync($tenantId)
    {
        return $this->getTenantAsyncWithHttpInfo($tenantId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTenantAsyncWithHttpInfo
     *
     * Retrieve a tenant by id
     *
     * @param string $tenantId (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTenantAsyncWithHttpInfo($tenantId)
    {
        $returnType = '\Killbill\Client\Swagger\Model\Tenant';
        $request = $this->getTenantRequest($tenantId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTenant'
     *
     * @param string $tenantId (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTenantRequest($tenantId)
    {
        // verify the required parameter 'tenantId' is set
        if ($tenantId === null || (is_array($tenantId) && count($tenantId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenantId when calling getTenant'
            );
        }

        $resourcePath = '/1.0/kb/tenants/{tenantId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($tenantId !== null) {
            $resourcePath = str_replace(
                '{' . 'tenantId' . '}',
                ObjectSerializer::toPathValue($tenantId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTenantByApiKey
     *
     * Retrieve a tenant by its API key
     *
     * @param string|null $apiKey apiKey (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Killbill\Client\Swagger\Model\Tenant
     */
    public function getTenantByApiKey($apiKey = null)
    {
        list($response) = $this->getTenantByApiKeyWithHttpInfo($apiKey);
        return $response;
    }

    /**
     * Operation getTenantByApiKeyWithHttpInfo
     *
     * Retrieve a tenant by its API key
     *
     * @param string $apiKey (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Killbill\Client\Swagger\Model\Tenant, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTenantByApiKeyWithHttpInfo($apiKey = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\Tenant';
        $request = $this->getTenantByApiKeyRequest($apiKey);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Killbill\Client\Swagger\Model\Tenant',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTenantByApiKeyAsync
     *
     * Retrieve a tenant by its API key
     *
     * @param string $apiKey (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTenantByApiKeyAsync($apiKey = null)
    {
        return $this->getTenantByApiKeyAsyncWithHttpInfo($apiKey)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTenantByApiKeyAsyncWithHttpInfo
     *
     * Retrieve a tenant by its API key
     *
     * @param string $apiKey (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTenantByApiKeyAsyncWithHttpInfo($apiKey = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\Tenant';
        $request = $this->getTenantByApiKeyRequest($apiKey);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTenantByApiKey'
     *
     * @param string $apiKey (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTenantByApiKeyRequest($apiKey = null)
    {

        $resourcePath = '/1.0/kb/tenants';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($apiKey !== null) {
            $queryParams['apiKey'] = ObjectSerializer::toQueryValue($apiKey);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUserKeyValue
     *
     * Retrieve a per tenant user key/value
     *
     * @param string $keyName keyName (required)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Killbill\Client\Swagger\Model\TenantKeyValue
     */
    public function getUserKeyValue($keyName)
    {
        list($response) = $this->getUserKeyValueWithHttpInfo($keyName);
        return $response;
    }

    /**
     * Operation getUserKeyValueWithHttpInfo
     *
     * Retrieve a per tenant user key/value
     *
     * @param string $keyName (required)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Killbill\Client\Swagger\Model\TenantKeyValue, HTTP status code, HTTP response headers (array of strings)
     */
    public function getUserKeyValueWithHttpInfo($keyName)
    {
        $returnType = '\Killbill\Client\Swagger\Model\TenantKeyValue';
        $request = $this->getUserKeyValueRequest($keyName);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Killbill\Client\Swagger\Model\TenantKeyValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getUserKeyValueAsync
     *
     * Retrieve a per tenant user key/value
     *
     * @param string $keyName (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserKeyValueAsync($keyName)
    {
        return $this->getUserKeyValueAsyncWithHttpInfo($keyName)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUserKeyValueAsyncWithHttpInfo
     *
     * Retrieve a per tenant user key/value
     *
     * @param string $keyName (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserKeyValueAsyncWithHttpInfo($keyName)
    {
        $returnType = '\Killbill\Client\Swagger\Model\TenantKeyValue';
        $request = $this->getUserKeyValueRequest($keyName);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getUserKeyValue'
     *
     * @param string $keyName (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getUserKeyValueRequest($keyName)
    {
        // verify the required parameter 'keyName' is set
        if ($keyName === null || (is_array($keyName) && count($keyName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $keyName when calling getUserKeyValue'
            );
        }

        $resourcePath = '/1.0/kb/tenants/userKeyValue/{keyName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($keyName !== null) {
            $resourcePath = str_replace(
                '{' . 'keyName' . '}',
                ObjectSerializer::toPathValue($keyName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation insertUserKeyValue
     *
     * Add a per tenant user key/value
     *
     * @param string $body body (required)
     * @param string $xKillbillCreatedBy xKillbillCreatedBy (required)
     * @param string $keyName keyName (required)
     * @param string|null $xKillbillReason xKillbillReason (optional)
     * @param string|null $xKillbillComment xKillbillComment (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Killbill\Client\Swagger\Model\TenantKeyValue
     */
    public function insertUserKeyValue($body, $xKillbillCreatedBy, $keyName, $xKillbillReason = null, $xKillbillComment = null)
    {
        list($response) = $this->insertUserKeyValueWithHttpInfo($body, $xKillbillCreatedBy, $keyName, $xKillbillReason, $xKillbillComment);
        return $response;
    }

    /**
     * Operation insertUserKeyValueWithHttpInfo
     *
     * Add a per tenant user key/value
     *
     * @param string $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $keyName (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Killbill\Client\Swagger\Model\TenantKeyValue, HTTP status code, HTTP response headers (array of strings)
     */
    public function insertUserKeyValueWithHttpInfo($body, $xKillbillCreatedBy, $keyName, $xKillbillReason = null, $xKillbillComment = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\TenantKeyValue';
        $request = $this->insertUserKeyValueRequest($body, $xKillbillCreatedBy, $keyName, $xKillbillReason, $xKillbillComment);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Killbill\Client\Swagger\Model\TenantKeyValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation insertUserKeyValueAsync
     *
     * Add a per tenant user key/value
     *
     * @param string $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $keyName (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertUserKeyValueAsync($body, $xKillbillCreatedBy, $keyName, $xKillbillReason = null, $xKillbillComment = null)
    {
        return $this->insertUserKeyValueAsyncWithHttpInfo($body, $xKillbillCreatedBy, $keyName, $xKillbillReason, $xKillbillComment)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation insertUserKeyValueAsyncWithHttpInfo
     *
     * Add a per tenant user key/value
     *
     * @param string $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $keyName (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertUserKeyValueAsyncWithHttpInfo($body, $xKillbillCreatedBy, $keyName, $xKillbillReason = null, $xKillbillComment = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\TenantKeyValue';
        $request = $this->insertUserKeyValueRequest($body, $xKillbillCreatedBy, $keyName, $xKillbillReason, $xKillbillComment);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'insertUserKeyValue'
     *
     * @param string $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $keyName (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function insertUserKeyValueRequest($body, $xKillbillCreatedBy, $keyName, $xKillbillReason = null, $xKillbillComment = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling insertUserKeyValue'
            );
        }
        // verify the required parameter 'xKillbillCreatedBy' is set
        if ($xKillbillCreatedBy === null || (is_array($xKillbillCreatedBy) && count($xKillbillCreatedBy) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $xKillbillCreatedBy when calling insertUserKeyValue'
            );
        }
        // verify the required parameter 'keyName' is set
        if ($keyName === null || (is_array($keyName) && count($keyName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $keyName when calling insertUserKeyValue'
            );
        }

        $resourcePath = '/1.0/kb/tenants/userKeyValue/{keyName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($xKillbillCreatedBy !== null) {
            $headerParams['X-Killbill-CreatedBy'] = ObjectSerializer::toHeaderValue($xKillbillCreatedBy);
        }
        // header params
        if ($xKillbillReason !== null) {
            $headerParams['X-Killbill-Reason'] = ObjectSerializer::toHeaderValue($xKillbillReason);
        }
        // header params
        if ($xKillbillComment !== null) {
            $headerParams['X-Killbill-Comment'] = ObjectSerializer::toHeaderValue($xKillbillComment);
        }

        // path params
        if ($keyName !== null) {
            $resourcePath = str_replace(
                '{' . 'keyName' . '}',
                ObjectSerializer::toPathValue($keyName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['text/plain']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation registerPushNotificationCallback
     *
     * Create a push notification
     *
     * @param string $xKillbillCreatedBy xKillbillCreatedBy (required)
     * @param string|null $cb cb (optional)
     * @param string|null $xKillbillReason xKillbillReason (optional)
     * @param string|null $xKillbillComment xKillbillComment (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Killbill\Client\Swagger\Model\TenantKeyValue
     */
    public function registerPushNotificationCallback($xKillbillCreatedBy, $cb = null, $xKillbillReason = null, $xKillbillComment = null)
    {
        list($response) = $this->registerPushNotificationCallbackWithHttpInfo($xKillbillCreatedBy, $cb, $xKillbillReason, $xKillbillComment);
        return $response;
    }

    /**
     * Operation registerPushNotificationCallbackWithHttpInfo
     *
     * Create a push notification
     *
     * @param string $xKillbillCreatedBy (required)
     * @param string $cb (optional)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Killbill\Client\Swagger\Model\TenantKeyValue, HTTP status code, HTTP response headers (array of strings)
     */
    public function registerPushNotificationCallbackWithHttpInfo($xKillbillCreatedBy, $cb = null, $xKillbillReason = null, $xKillbillComment = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\TenantKeyValue';
        $request = $this->registerPushNotificationCallbackRequest($xKillbillCreatedBy, $cb, $xKillbillReason, $xKillbillComment);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Killbill\Client\Swagger\Model\TenantKeyValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation registerPushNotificationCallbackAsync
     *
     * Create a push notification
     *
     * @param string $xKillbillCreatedBy (required)
     * @param string $cb (optional)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function registerPushNotificationCallbackAsync($xKillbillCreatedBy, $cb = null, $xKillbillReason = null, $xKillbillComment = null)
    {
        return $this->registerPushNotificationCallbackAsyncWithHttpInfo($xKillbillCreatedBy, $cb, $xKillbillReason, $xKillbillComment)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation registerPushNotificationCallbackAsyncWithHttpInfo
     *
     * Create a push notification
     *
     * @param string $xKillbillCreatedBy (required)
     * @param string $cb (optional)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function registerPushNotificationCallbackAsyncWithHttpInfo($xKillbillCreatedBy, $cb = null, $xKillbillReason = null, $xKillbillComment = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\TenantKeyValue';
        $request = $this->registerPushNotificationCallbackRequest($xKillbillCreatedBy, $cb, $xKillbillReason, $xKillbillComment);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'registerPushNotificationCallback'
     *
     * @param string $xKillbillCreatedBy (required)
     * @param string $cb (optional)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function registerPushNotificationCallbackRequest($xKillbillCreatedBy, $cb = null, $xKillbillReason = null, $xKillbillComment = null)
    {
        // verify the required parameter 'xKillbillCreatedBy' is set
        if ($xKillbillCreatedBy === null || (is_array($xKillbillCreatedBy) && count($xKillbillCreatedBy) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $xKillbillCreatedBy when calling registerPushNotificationCallback'
            );
        }

        $resourcePath = '/1.0/kb/tenants/registerNotificationCallback';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($cb !== null) {
            $queryParams['cb'] = ObjectSerializer::toQueryValue($cb);
        }
        // header params
        if ($xKillbillCreatedBy !== null) {
            $headerParams['X-Killbill-CreatedBy'] = ObjectSerializer::toHeaderValue($xKillbillCreatedBy);
        }
        // header params
        if ($xKillbillReason !== null) {
            $headerParams['X-Killbill-Reason'] = ObjectSerializer::toHeaderValue($xKillbillReason);
        }
        // header params
        if ($xKillbillComment !== null) {
            $headerParams['X-Killbill-Comment'] = ObjectSerializer::toHeaderValue($xKillbillComment);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation uploadPerTenantConfiguration
     *
     * Add a per tenant configuration (system properties)
     *
     * @param string $body body (required)
     * @param string $xKillbillCreatedBy xKillbillCreatedBy (required)
     * @param string|null $xKillbillReason xKillbillReason (optional)
     * @param string|null $xKillbillComment xKillbillComment (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Killbill\Client\Swagger\Model\TenantKeyValue
     */
    public function uploadPerTenantConfiguration($body, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        list($response) = $this->uploadPerTenantConfigurationWithHttpInfo($body, $xKillbillCreatedBy, $xKillbillReason, $xKillbillComment);
        return $response;
    }

    /**
     * Operation uploadPerTenantConfigurationWithHttpInfo
     *
     * Add a per tenant configuration (system properties)
     *
     * @param string $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Killbill\Client\Swagger\Model\TenantKeyValue, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadPerTenantConfigurationWithHttpInfo($body, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\TenantKeyValue';
        $request = $this->uploadPerTenantConfigurationRequest($body, $xKillbillCreatedBy, $xKillbillReason, $xKillbillComment);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Killbill\Client\Swagger\Model\TenantKeyValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation uploadPerTenantConfigurationAsync
     *
     * Add a per tenant configuration (system properties)
     *
     * @param string $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadPerTenantConfigurationAsync($body, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        return $this->uploadPerTenantConfigurationAsyncWithHttpInfo($body, $xKillbillCreatedBy, $xKillbillReason, $xKillbillComment)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadPerTenantConfigurationAsyncWithHttpInfo
     *
     * Add a per tenant configuration (system properties)
     *
     * @param string $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadPerTenantConfigurationAsyncWithHttpInfo($body, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\TenantKeyValue';
        $request = $this->uploadPerTenantConfigurationRequest($body, $xKillbillCreatedBy, $xKillbillReason, $xKillbillComment);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'uploadPerTenantConfiguration'
     *
     * @param string $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function uploadPerTenantConfigurationRequest($body, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling uploadPerTenantConfiguration'
            );
        }
        // verify the required parameter 'xKillbillCreatedBy' is set
        if ($xKillbillCreatedBy === null || (is_array($xKillbillCreatedBy) && count($xKillbillCreatedBy) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $xKillbillCreatedBy when calling uploadPerTenantConfiguration'
            );
        }

        $resourcePath = '/1.0/kb/tenants/uploadPerTenantConfig';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($xKillbillCreatedBy !== null) {
            $headerParams['X-Killbill-CreatedBy'] = ObjectSerializer::toHeaderValue($xKillbillCreatedBy);
        }
        // header params
        if ($xKillbillReason !== null) {
            $headerParams['X-Killbill-Reason'] = ObjectSerializer::toHeaderValue($xKillbillReason);
        }
        // header params
        if ($xKillbillComment !== null) {
            $headerParams['X-Killbill-Comment'] = ObjectSerializer::toHeaderValue($xKillbillComment);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['text/plain']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation uploadPluginConfiguration
     *
     * Add a per tenant configuration for a plugin
     *
     * @param string $body body (required)
     * @param string $xKillbillCreatedBy xKillbillCreatedBy (required)
     * @param string $pluginName pluginName (required)
     * @param string|null $xKillbillReason xKillbillReason (optional)
     * @param string|null $xKillbillComment xKillbillComment (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Killbill\Client\Swagger\Model\TenantKeyValue
     */
    public function uploadPluginConfiguration($body, $xKillbillCreatedBy, $pluginName, $xKillbillReason = null, $xKillbillComment = null)
    {
        list($response) = $this->uploadPluginConfigurationWithHttpInfo($body, $xKillbillCreatedBy, $pluginName, $xKillbillReason, $xKillbillComment);
        return $response;
    }

    /**
     * Operation uploadPluginConfigurationWithHttpInfo
     *
     * Add a per tenant configuration for a plugin
     *
     * @param string $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $pluginName (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Killbill\Client\Swagger\Model\TenantKeyValue, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadPluginConfigurationWithHttpInfo($body, $xKillbillCreatedBy, $pluginName, $xKillbillReason = null, $xKillbillComment = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\TenantKeyValue';
        $request = $this->uploadPluginConfigurationRequest($body, $xKillbillCreatedBy, $pluginName, $xKillbillReason, $xKillbillComment);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Killbill\Client\Swagger\Model\TenantKeyValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation uploadPluginConfigurationAsync
     *
     * Add a per tenant configuration for a plugin
     *
     * @param string $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $pluginName (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadPluginConfigurationAsync($body, $xKillbillCreatedBy, $pluginName, $xKillbillReason = null, $xKillbillComment = null)
    {
        return $this->uploadPluginConfigurationAsyncWithHttpInfo($body, $xKillbillCreatedBy, $pluginName, $xKillbillReason, $xKillbillComment)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadPluginConfigurationAsyncWithHttpInfo
     *
     * Add a per tenant configuration for a plugin
     *
     * @param string $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $pluginName (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadPluginConfigurationAsyncWithHttpInfo($body, $xKillbillCreatedBy, $pluginName, $xKillbillReason = null, $xKillbillComment = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\TenantKeyValue';
        $request = $this->uploadPluginConfigurationRequest($body, $xKillbillCreatedBy, $pluginName, $xKillbillReason, $xKillbillComment);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'uploadPluginConfiguration'
     *
     * @param string $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $pluginName (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function uploadPluginConfigurationRequest($body, $xKillbillCreatedBy, $pluginName, $xKillbillReason = null, $xKillbillComment = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling uploadPluginConfiguration'
            );
        }
        // verify the required parameter 'xKillbillCreatedBy' is set
        if ($xKillbillCreatedBy === null || (is_array($xKillbillCreatedBy) && count($xKillbillCreatedBy) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $xKillbillCreatedBy when calling uploadPluginConfiguration'
            );
        }
        // verify the required parameter 'pluginName' is set
        if ($pluginName === null || (is_array($pluginName) && count($pluginName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pluginName when calling uploadPluginConfiguration'
            );
        }

        $resourcePath = '/1.0/kb/tenants/uploadPluginConfig/{pluginName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($xKillbillCreatedBy !== null) {
            $headerParams['X-Killbill-CreatedBy'] = ObjectSerializer::toHeaderValue($xKillbillCreatedBy);
        }
        // header params
        if ($xKillbillReason !== null) {
            $headerParams['X-Killbill-Reason'] = ObjectSerializer::toHeaderValue($xKillbillReason);
        }
        // header params
        if ($xKillbillComment !== null) {
            $headerParams['X-Killbill-Comment'] = ObjectSerializer::toHeaderValue($xKillbillComment);
        }

        // path params
        if ($pluginName !== null) {
            $resourcePath = str_replace(
                '{' . 'pluginName' . '}',
                ObjectSerializer::toPathValue($pluginName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['text/plain']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation uploadPluginPaymentStateMachineConfig
     *
     * Add a per tenant payment state machine for a plugin
     *
     * @param string $body body (required)
     * @param string $xKillbillCreatedBy xKillbillCreatedBy (required)
     * @param string $pluginName pluginName (required)
     * @param string|null $xKillbillReason xKillbillReason (optional)
     * @param string|null $xKillbillComment xKillbillComment (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Killbill\Client\Swagger\Model\TenantKeyValue
     */
    public function uploadPluginPaymentStateMachineConfig($body, $xKillbillCreatedBy, $pluginName, $xKillbillReason = null, $xKillbillComment = null)
    {
        list($response) = $this->uploadPluginPaymentStateMachineConfigWithHttpInfo($body, $xKillbillCreatedBy, $pluginName, $xKillbillReason, $xKillbillComment);
        return $response;
    }

    /**
     * Operation uploadPluginPaymentStateMachineConfigWithHttpInfo
     *
     * Add a per tenant payment state machine for a plugin
     *
     * @param string $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $pluginName (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Killbill\Client\Swagger\Model\TenantKeyValue, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadPluginPaymentStateMachineConfigWithHttpInfo($body, $xKillbillCreatedBy, $pluginName, $xKillbillReason = null, $xKillbillComment = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\TenantKeyValue';
        $request = $this->uploadPluginPaymentStateMachineConfigRequest($body, $xKillbillCreatedBy, $pluginName, $xKillbillReason, $xKillbillComment);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Killbill\Client\Swagger\Model\TenantKeyValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation uploadPluginPaymentStateMachineConfigAsync
     *
     * Add a per tenant payment state machine for a plugin
     *
     * @param string $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $pluginName (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadPluginPaymentStateMachineConfigAsync($body, $xKillbillCreatedBy, $pluginName, $xKillbillReason = null, $xKillbillComment = null)
    {
        return $this->uploadPluginPaymentStateMachineConfigAsyncWithHttpInfo($body, $xKillbillCreatedBy, $pluginName, $xKillbillReason, $xKillbillComment)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadPluginPaymentStateMachineConfigAsyncWithHttpInfo
     *
     * Add a per tenant payment state machine for a plugin
     *
     * @param string $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $pluginName (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadPluginPaymentStateMachineConfigAsyncWithHttpInfo($body, $xKillbillCreatedBy, $pluginName, $xKillbillReason = null, $xKillbillComment = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\TenantKeyValue';
        $request = $this->uploadPluginPaymentStateMachineConfigRequest($body, $xKillbillCreatedBy, $pluginName, $xKillbillReason, $xKillbillComment);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'uploadPluginPaymentStateMachineConfig'
     *
     * @param string $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $pluginName (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function uploadPluginPaymentStateMachineConfigRequest($body, $xKillbillCreatedBy, $pluginName, $xKillbillReason = null, $xKillbillComment = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling uploadPluginPaymentStateMachineConfig'
            );
        }
        // verify the required parameter 'xKillbillCreatedBy' is set
        if ($xKillbillCreatedBy === null || (is_array($xKillbillCreatedBy) && count($xKillbillCreatedBy) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $xKillbillCreatedBy when calling uploadPluginPaymentStateMachineConfig'
            );
        }
        // verify the required parameter 'pluginName' is set
        if ($pluginName === null || (is_array($pluginName) && count($pluginName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pluginName when calling uploadPluginPaymentStateMachineConfig'
            );
        }

        $resourcePath = '/1.0/kb/tenants/uploadPluginPaymentStateMachineConfig/{pluginName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($xKillbillCreatedBy !== null) {
            $headerParams['X-Killbill-CreatedBy'] = ObjectSerializer::toHeaderValue($xKillbillCreatedBy);
        }
        // header params
        if ($xKillbillReason !== null) {
            $headerParams['X-Killbill-Reason'] = ObjectSerializer::toHeaderValue($xKillbillReason);
        }
        // header params
        if ($xKillbillComment !== null) {
            $headerParams['X-Killbill-Comment'] = ObjectSerializer::toHeaderValue($xKillbillComment);
        }

        // path params
        if ($pluginName !== null) {
            $resourcePath = str_replace(
                '{' . 'pluginName' . '}',
                ObjectSerializer::toPathValue($pluginName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['text/plain']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }


    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
    
    /**
     * Response handler
     *
     * @param Request  $request    Request
     * @param Response $response   Response
     * @param string   $returnType Return type
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @return array of returned object matching type, HTTP status code, HTTP response headers (array of strings)
     */
    protected function handleResponse($request, $response, $returnType)
    {
        $statusCode = $response->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $request->getUri()
                ),
                $statusCode,
                $response->getHeaders(),
                $response->getBody()
            );
        }

        if ($statusCode === 201 && $response->hasHeader('Location')) {
            // This is a Created redirection, getting the object from the location target
            $location = $response->getHeader('Location')[0];

            if (strpos($location, $this->config->getHost()) !== 0) {
                throw new ApiException(
                    sprintf(
                        '[%d] Received a location header not matching the configured host (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $options = $this->createHttpClientOption();
            $locationRequest = new Request(
                'GET',
                $location,
                $request->getHeaders()
            );
            $locationResponse = $this->client->send($locationRequest, $options);

            $responseBody = $locationResponse->getBody();
        } else {
            $responseBody = $response->getBody();
        }

        if ($returnType === null || $returnType === '') {
            $returnedObject = null;
        } else {
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }
            
            $returnedObject = ObjectSerializer::deserialize($content, $returnType, []);
        }

        return [
            $returnedObject,
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }
}
